We want to prove that \(F_k(x) := H (k \abs{} x)\) is a pseudorandom function.\\
To simulate the PRF-game for our adversary \(\mathcal{A}\) against the PRF, we sample \(k\) and bit \(b\) randomly. Furthermore we choose a truely random function \(f(x)\) randomly. \\
If \(b= 0\), then we answer each query \(x\) of \(\mathcal{A}\) with the result of the random oracle \(H\), queried with \(k \abs{} x\).\\
If \(b= 1\), then we answer each query \(x\) of \(\mathcal{A}\) with the result of \(f(k \abs{} x)\).\\
\(\mathcal{A}\) then outputs \(b'\) and wins if \(b' = b\).\\
Efficiency?\\
To analyse the success we see, that \(\mathcal{A}\) has to distinguish two cases: A truely random generated bitstring and the output from the random oracle, which is random per definition. \\
So \(\abs{Pr[\mathcal{A}^{F(k,\cdot)}(1^{\lambda})= 1]= Pr[\mathcal{A}^{f(\cdot)}(1^{\lambda})= 1]} \le negl(\lambda)\).\\
It follows that \(F_k(x) := H (k \abs{} x)\) is a pseudorandom function.



%We assume towards contradiction, that there exists an efficient adversary \(\mathcal{A}\) against the pseudorandomness of \(F\). That means, that \(\mathcal{A}\) can distinguish between a pseudorandom function and a truely random function with non-negligible probability \(\epsilon\).\\
%We now construct an adversary \(\mathcal{B}\) against the Quadratic Residuosity Assumption as follows:\\
%\(\mathcal{B}\) invokes \(\mathcal{A}\) and answers any query of \(x\) by asking \(k \abs{} x\) to the random oracle \(H\) and returns the answer of \(H\) to \(\mathcal{A}\). \(H\) is constructed as follows: If \(k \abs{} x\) was already queried to \(H\) the saved \(H(k \abs{} x)\) is returned. Otherwise \(H\) returns the next value \(q\) \(\mathcal{B}\) gets from his oracle (which outputs either \(qr \in QR_N\) or \(qnr \in QNR_N\)) which is different from the previous values of \(q\) and saves the resulting pair \((x, q)\).
%Eventually \(\mathcal{A}\) outputs a bit \(b'\) and \(\mathcal{B}\) outputs the same bit.\\
%\(\mathcal{B}\) invokes \(\mathcal{A}\) and \(\mathcal{A}\) is efficient and so the message length are poly. Furthermore forwarding messages and storing and searching in poly many value pairs can be done in poly time too. So \(\mathcal{B}\) is also efficient.\\
%To analyse the success, we distinguish two different cases:\\
%If \(qr \in QR_N\) 
 
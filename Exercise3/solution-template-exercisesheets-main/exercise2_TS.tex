% \input{exercise2_TS.tex} &In exercise2.tex Datei einfÃ¼gen

\begin{itemize}
\item[(a)]
	Is G\(_{a}\)(s) = G(s)\(\vert \vert\)0 a secure PRG? \\
	No since the last bit is always 0. This bit is not uniformly at random because the probablitiy of that bit being 0 is 100\(\%\) instead of 50\(\%\). \\
	\(\Rightarrow\)  G\(_{a}\) is a not a PRG
\item[(b)]
	Is G\(_{b}\)(s\(\vert \vert\)b) = G(s)\(\vert \vert\)b where \(\vert\)b\(\vert\) = 1 a secure PRG? \\
	Yes because adding a single random but fixed bit has the probability 50\(\%\) being 1 and  50\(\%\) being 0 meaning b is uniformly random.
	b = \(\{0,1\}\) is a pseudorandom generator and the concatination of two pseudorandom number generators is a pseudorandom number generator itself.
	Also since b is part of the argument G\(_{b}\) is deterministic. \\
	\(\Rightarrow\)  G\(_{b}\) is a secure PRG\\
\item[(c)]
	Is G\(_{c}\)(s) = G(s\(\vert \vert\)0) a secure PRG? \\
	Assume  G\(_{c}\)(s)  is not a secure PRG and an adversary A that can distinguish between  G\(_{c}\)(s) and a random generator g(s).\\
	We construct \(\mathcal{B}\) that \(\mathcal{A}\)  and adds a 0 to each string s.\\
	Since G(s) is a secure PRG and therfore its values uniformly distributed it follows that \(\mathcal{B}\) is as efficient as \(\mathcal{A}\).\\
	\(\Rightarrow\) G\(_{c}\)(s) is a secure PRG.
\item[(d)]
	Is G\(_{d}\)(s) = G(s\(\vert \vert\)\(0^{\vert s \vert}\)) a secure PRG? \\
	Is G\(_{d}\)(s) = G(s\(\vert \vert\)0) a secure PRG? \\
	Assume  G\(_{d}\)(s)  is not a secure PRG and an adversary A that can distinguish between  G\(_{d}\)(s) and a random generator g(s).\\
	We construct \(\mathcal{B}\) that \(\mathcal{A}\)  and adds l(\(\vert\)b\(\vert\))-times 0 to each string s.\\
	Since G(s) is a secure PRG and therfore its values uniformly distributed it follows that \(\mathcal{B}\) is as efficient as \(\mathcal{A}\).\\
	\(\Rightarrow\) G\(_{d}\)(s) is a secure PRG.
\item[(e)]
	Is G\(_{e}\)(s) = G(s) \(\xor\) \(1^{ l(\vert s \vert)}\) a secure PG? \\
	Assume  G\(_{e}\)(s)  is not a secure PRG and an adversary A that can distinguish between  G\(_{e}\)(s) and a random generator g(s).\\
	We construct \(\mathcal{B}\) that calls the function F(s) = s \(\xor\) \(1^{ l(\vert s \vert)}\) = G(s) for s = G\(_{e}\)(s).
	For \(\mathcal{B}\) to distinguish the one case where b is set correctly from g(s) \(\mathcal{B}\) has to distinguish (G(\textit{trunc}(s)) from g(s).\\
	However since G(s) is a secure definition by definition.
	\(\Rightarrow\)  contradiction\\
	\(\Rightarrow\) G\(_{f}\)(s) is a secure PRG.
\item[(f)]
	Is G\(_{f}\)(s) = \textit{trunc}(G(\textit{trunc}(s))) a secure PRG? \\
	where \textit{trunc}(x) for a nonempty string x denotes all but the last bit of x. \\
	(For this part, assume that l(n) >  n + 2, and ignore the fact that G\(_{f}\) is undefined on input strings of length 1.) \\
	\\
	Assume G\(_{f}\)(s) is not a secure PRG and an adversary \(\mathcal{A}\) can distinguish between G\(_{f}\)(s) and a random generator g(s).\\
	We construct an adversary \(\mathcal{B}\) that evokes \(\mathcal{A}\) adds one bit b =\{0,1\} to  G\(_{f}\)(s).\\
	For \(\mathcal{B}\) to distinguish the one case where b is set correctly from g(s) \(\mathcal{B}\) would have to distinguish G(\textit{trunc}(s)) from g(s).\\
	However since G(s) is a secure definition by definition. Furthermore \(\mathcal{B}\) can't know what value \textit{trunc} has deleted from the string since 		G(s) is uniformly distributed.
	\(\Rightarrow\)  contradiction\\
	\(\Rightarrow\) G\(_{f}\)(s) is a secure PRG.
\end{itemize}

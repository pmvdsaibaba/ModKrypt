\begin{itemize}
\item [(a)]
	\textbf{To show:} Prove that regular CPA security implies \(\lambda\)-CPA security.\\
	We do this by a reduction. We assume there is an efficient adversary \(\mathcal{A}\) against the \(\lambda\)-CPA-security of \(\Pi\) which is successful with non-negligible probability. From this we construct our adversary \(\mathcal{B}\) against the CPA-security of \(\Pi\) which invokes \(\mathcal{A}\). \(\mathcal{B}\) has to provide an encryption oracle for \(\mathcal{A}\).
	To do this, he forwards any message \(m\) \(\mathcal{A}\) sends to his oracle to his own oracle and recieves the ciphertext \(c\). He then makes a vector \(\vec{C}\), which contains \(\lambda\)-times the ciphertext \(c\), and forwards it to \(\mathcal{A}\) \todo{So ok and possible?}. \\
	\(\mathcal{A}\) eventually outputs two messages \((\widetilde{m_0}, \widetilde{m_1})\), which \(\mathcal{B}\) forwards to his challenger. Then he sends an vector \(\vec{C_b}\) to \(\mathcal{A}\), which contains  \(\lambda\)-times the recieved ciphertext \(c_b\). Then \(\mathcal{B}\) outputs the same bit \(b\) like \(\mathcal{A}\) does. \\
	\(\mathcal{B}\) invokes \(\mathcal{A}\) and \(\mathcal{A}\) is efficient. Because of that, the message length have to be poly. Furthermore forwarding messages is in poly time too. So \(\mathcal{B}\) is efficient.\\
	To analyse the success, we ascertain, that \(\mathcal{B}\) simulates the \(\lambda\)-CPA-game perfectly to \(\mathcal{A}\). So the success probability of \(\mathcal{B}\) is the same as \(\mathcal{A}\), which is non-negligible. This is a contradiction to the CPA security of \(\mathcal{B}\), so such an adversary \(\mathcal{A}\) cannot exit. \\
	It follows that the scheme is \(\lambda\)-CPA secure, if it CPA secure. In other words, regular CPA security implies \(\lambda\)-CPA security.
\item [(b)]
	\textbf{To show:} Prove that \(\lambda\)-CPA security implies normal CPA security.\\
	We do this by a reduction. We assume there is an efficient adversary \(\mathcal{A}\) against the CPA-security of \(\Pi\) which is successful with non-negligible probability. From this we construct our adversary \(\mathcal{B}\) against the \(\lambda\)-CPA-security of \(\Pi\) which invokes \(\mathcal{A}\). \(\mathcal{B}\) has to provide an encryption oracle for \(\mathcal{A}\).
	To do this, he forwards any message \(m\) \(\mathcal{A}\) sends to his oracle to his own oracle and recieves the ciphertextvector \(\vec{C} = (c_1, ... , c_{\lambda})\). He then forwards only the first ciphertext \(c_1\) to \(\mathcal{A}\). \\
	\(\mathcal{A}\) eventually outputs two messages \((\widetilde{m_0}, \widetilde{m_1})\), which \(\mathcal{B}\) forwards to his challenger. From the recieved ciphertextvector \(\vec{C_b}\) he again forwards only the first ciphertext to \(\mathcal{A}\). Then \(\mathcal{B}\) outputs the same bit \(b\) like \(\mathcal{A}\) does. \\
	\(\mathcal{B}\) invokes \(\mathcal{A}\) and \(\mathcal{A}\) is efficient. Because of that, the message length have to be poly. Furthermore forwarding messages is in poly time too. So \(\mathcal{B}\) is efficient.\\
	To analyse the success, we ascertain, that \(\mathcal{B}\) simulates the CPA-game perfectly to \(\mathcal{A}\). So the success probability of \(\mathcal{B}\) is the same as \(\mathcal{A}\), which is non-negligible. This is a contradiction to the \(\lambda\)-CPA security of \(\mathcal{B}\), so such an adversary \(\mathcal{A}\) cannot exit. \\
	It follows that the scheme is CPA secure, if it \(\lambda\)-CPA secure. In other words, \(\lambda\)-CPA security implies normal CPA security.
\end{itemize}

